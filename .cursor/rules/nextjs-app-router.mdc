---
globs: app/**/*.tsx,app/**/*.ts
description: Next.js 15 App Router 사용 규칙
---

# Next.js 15 App Router 규칙

이 프로젝트는 Next.js 15의 App Router를 사용합니다.

## 파일 구조 및 라우팅

### 필수 파일 규칙
- `page.tsx` - 공개 라우트 페이지 (URL에 직접 접근 가능)
- `layout.tsx` - 공유 레이아웃 (여러 페이지에서 재사용)
- `loading.tsx` - 로딩 UI (React Suspense 기반)
- `error.tsx` - 에러 처리 UI
- `not-found.tsx` - 404 페이지

### 동적 라우팅
- 폴더 이름을 `[id]` 또는 `[slug]` 형식으로 사용
- 예: `app/products/[id]/page.tsx`

```tsx
// app/products/[id]/page.tsx
export default async function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  // params는 Promise이므로 반드시 await 필요
  return <div>Product {id}</div>
}
```

### generateStaticParams 사용
동적 라우트를 정적 생성할 때:

```tsx
export async function generateStaticParams() {
  const products = await fetch('https://api.example.com/products').then(res => res.json())
  
  return products.map((product) => ({
    id: String(product.id),
  }))
}
```

## Server Components vs Client Components

### Server Components (기본)
- **기본값**: 모든 컴포넌트는 Server Component
- 서버에서 실행되어 클라이언트 번들 크기 감소
- 데이터베이스, 파일 시스템 등 서버 리소스 직접 접근 가능
- async/await 사용 가능

```tsx
// Server Component (기본)
export default async function Page() {
  const data = await fetch('https://api.example.com/data')
  const posts = await data.json()
  
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### Client Components
- `'use client'` 지시어 사용
- 브라우저 이벤트, React hooks(useState, useEffect 등) 필요할 때 사용
- 가능한 한 컴포넌트 트리의 말단에 배치하여 번들 크기 최소화

```tsx
'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  )
}
```

### 컴포넌트 구성 패턴
- Server Component 내에서 Client Component 사용 가능
- Client Component 내에서는 Server Component를 직접 임포트 불가
- Client Component에 Server Component를 props로 전달하는 것은 가능

```tsx
// ✅ 올바른 패턴
// app/page.tsx (Server Component)
import ClientComponent from './client-component'

export default async function Page() {
  const data = await fetchData()
  
  return (
    <ClientComponent data={data} />
  )
}
```

## 데이터 페칭

### fetch API 사용
Next.js 15는 fetch API를 확장하여 캐싱 및 재검증 옵션 제공:

```tsx
// 정적 데이터 (기본값)
const staticData = await fetch('https://api.example.com/data', {
  cache: 'force-cache'
})

// 동적 데이터 (매 요청마다 재페칭)
const dynamicData = await fetch('https://api.example.com/data', {
  cache: 'no-store'
})

// ISR (Incremental Static Regeneration)
const revalidatedData = await fetch('https://api.example.com/data', {
  next: { revalidate: 60 } // 60초마다 재검증
})
```

### ORM/Database 사용
```tsx
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  
  return (
    <ul>
      {allPosts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### 병렬 데이터 페칭
네트워크 워터폴을 줄이기 위해 가능한 경우 병렬로 페칭:

```tsx
export default async function Page() {
  // ✅ 병렬 페칭
  const [posts, users] = await Promise.all([
    fetch('https://api.example.com/posts').then(res => res.json()),
    fetch('https://api.example.com/users').then(res => res.json())
  ])
  
  return <div>...</div>
}
```

## 서버 액션 (Server Actions)

### 폼 제출 및 데이터 변경
```tsx
// app/actions.ts
'use server'

export async function createProduct(formData: FormData) {
  const name = formData.get('name')
  const price = formData.get('price')
  
  // 데이터베이스 작업
  await db.insert({ name, price })
  
  // 페이지 재검증
  revalidatePath('/products')
}
```

```tsx
// app/products/new/page.tsx
import { createProduct } from '@/app/actions'

export default function NewProductPage() {
  return (
    <form action={createProduct}>
      <input name="name" required />
      <input name="price" type="number" required />
      <button type="submit">등록</button>
    </form>
  )
}
```

### 보안
- Server Actions에서 항상 사용자 인증 및 권한 확인
- 민감한 데이터는 tainting을 사용하여 클라이언트 노출 방지

## 라우트 핸들러 (Route Handlers)

API 엔드포인트 생성: `app/api/*/route.ts`

```tsx
// app/api/products/route.ts
export async function GET(request: Request) {
  const products = await db.select().from(products)
  return Response.json(products)
}

export async function POST(request: Request) {
  const body = await request.json()
  await db.insert(body)
  return Response.json({ success: true })
}
```

**주의**: Server Component에서 Route Handler를 호출하지 마세요. 추가 서버 요청이 발생합니다. Server Component에서는 직접 데이터 페칭을 수행하세요.

## Navigation Hooks

### Client Component에서 라우팅
```tsx
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function Component() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()
  
  // 프로그래밍 방식 네비게이션
  router.push('/dashboard')
  router.refresh()
  router.back()
  
  return <div>Current path: {pathname}</div>
}
```

### Link 컴포넌트
```tsx
import Link from 'next/link'

export default function Nav() {
  return (
    <nav>
      <Link href="/products" prefetch={true}>
        상품 목록
      </Link>
    </nav>
  )
}
```

## 메타데이터

### 정적 메타데이터
```tsx
// app/products/page.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: '상품 목록 - 키위마켓',
  description: '우리 동네 중고 상품을 찾아보세요',
}

export default function ProductsPage() {
  return <div>...</div>
}
```

### 동적 메타데이터
```tsx
// app/products/[id]/page.tsx
export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>
}): Promise<Metadata> {
  const { id } = await params
  const product = await fetchProduct(id)
  
  return {
    title: `${product.name} - 키위마켓`,
    description: product.description,
  }
}
```

## 스트리밍 및 Suspense

### 로딩 UI
```tsx
// app/products/loading.tsx
export default function Loading() {
  return <div>로딩 중...</div>
}
```

### Suspense 사용
```tsx
import { Suspense } from 'react'

export default function Page() {
  return (
    <div>
      <h1>상품 목록</h1>
      <Suspense fallback={<div>상품을 불러오는 중...</div>}>
        <ProductList />
      </Suspense>
    </div>
  )
}
```

## Dynamic APIs

다음 API 사용 시 전체 라우트가 동적 렌더링으로 전환됩니다:
- `cookies()`
- `headers()`
- `searchParams` prop

```tsx
import { cookies, headers } from 'next/headers'

export default async function Page() {
  const cookieStore = await cookies()
  const theme = cookieStore.get('theme')
  
  const headersList = await headers()
  const userAgent = headersList.get('user-agent')
  
  return <div>Theme: {theme?.value}</div>
}
```

**권장사항**: Dynamic API를 의도적으로 사용하고, 가능한 경우 `<Suspense>` 경계로 감싸세요.

## 성능 최적화

1. **Server Component 우선 사용** - 클라이언트 번들 크기 감소
2. **병렬 데이터 페칭** - 네트워크 워터폴 최소화
3. **적절한 캐싱 전략** - fetch의 cache 옵션 활용
4. **Streaming과 Suspense** - 점진적 UI 렌더링
5. **Client Component 최소화** - 'use client' 경계를 트리 말단에 배치
6. **이미지 최적화** - next/image 사용
7. **폰트 최적화** - next/font 사용 (이미 [app/layout.tsx](mdc:app/layout.tsx)에 적용됨)